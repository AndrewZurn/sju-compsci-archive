Andrew Zurn
CS330 - Heroux
Ch. 25/26 Qs
11/29/12

-25-
1) Code tuning has been such a controversial topic over the years, because often when we decide to tune code, as an increase and efficiency or performance is needed, we sacrafice other areas of the program, such as readability or maintainability.  The book points out that over the years, as computers have become more powerful, we have needed to go to less extremes in code tuning as processing power and storage has increased.  But, it also points out that because of the modern mobile era that we are in right now, a return to efficient, performance-enhanced code has come back to the forefront, and as lessons of the past point out, it sometimes leaves a bad taste in peoples mouth.

2) Although the modern processor might have the same clock speeds as 5 years ago, the emergence of dual, quad, and many multiple core processors has given a massive boost to processing speeds.  Because we are working with multiple cores, all doing their own processing, rathing than just one core running all processes on the computer, we can begin to increase the workload we put into our machines.  We can program bigger, less efficient code, and know that because we have multiple cores running our system, we won't bog down the computer running it through these multiple processors.  Code tuning has more than likely taken a downturn again as our machines, with their multiple cores, are becoming so powerful that there is no real need to optimize our code to such extremes that might have been used in the past.

3) The Pareto Principle, as the books cites, also known as the 80/20 rule, states that "you can get 80 percent of the result with 20 percent of the effort." Essentially, it states that 80 percent of the results will come from 20 percent of the work.  In the question example, where if we have 1000 lines of code, 20% of that code, or 200 lines, will more than likely be the main workhorse of 80% of the performance of the program.  If we look at these number, we know that we are bound to only being able to find about a 20% increase in performance if we try to tune these 200 lines of code to bring us up to that 100% performance mark.

4) What the quote, in my interpretation states, is that code optimization almost should never be done (unless you are a super-crazy advanced expert, then you might have Jackson's permission to go ahead and tune away).  Beginners shouldn't tune, as they should more than likely just make sure the program functions correctly, and adhere to other coding principles, such as maintainability and readability.  Programming experts shouldn't tune, as it is still likely to hurt other areas of the program, and is probably not worth the effort, especially if we take into consideration the processing speeds that we can attain today.  It should be strictly reserver to those super-crazy advanced capital 'E' Experts to put up with the actual tuning of code.

-26-
1) The most important tool when tuning code would be benchmarking and timing the speeds of your 'performance enhancements.'  Without accurately measuring the speed of the enhancement, you won't know whether or not it actually improves anything.  Without the use of benchmarking or timing the speed of your code, code-tuning becoming irrelevant, as the results are never truly known for the optimization.

2) Knowing the computer architecture of the system upon which your working is definetly important when it comes to tuning your code.  Knowing how many processors your working on, if your using a multi-thread machine, and knowing the storage capabilities, what compilers are used, etc. will allow you to customize your code for those specific areas.  An example of code-tuning in this case might be in the use of compilers.  Everyone knows that Java is not nearly as fast as C or C++ are, as it is compiled into byte code and run though a Java Virtual Machine.  However, if we find a good "JIT", or "Just in time" compiler, we can begin to get our compilation times for Java a lot closer to those of C or C++, than we would be able to on a much slower compiler.
